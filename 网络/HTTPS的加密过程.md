# HTTPS的加密过程

- 客户端
- 服务端
- CA数字证书

## 加密算法

1. 对称加密：使用一个密钥（对数据进行加密和解密）

    - 1）使用会话密钥加密，使用会话密钥解密（客户端、服务端各有一个）
    - 2）存在泄漏会话密钥的风险（这一风险通过非对称加密进行身份验证和密钥协商来避免），但是运算速度比较快，性能较好
    - 3）一般是一对一的关系，服务器和客户端共享相同密钥；不同客户端密钥不同，服务器维护多个密钥

2. 非对称加密：使用公钥和私钥2个密钥（身份验证、协商密钥）

    - 1）公钥可以随意分发（公开），但是私钥要唯一保密（保密）
    - 2）公钥加密的内容可以使用私钥解密，私钥加密的内容也可以使用公钥解密
    - 3）这种加密算法比较安全，但是性能上一般，速度比较慢（所以，在使用该方式验证身份后，后面就全部使用对称加密的方式）
    - 4）一般是一对多的关系，客户端共享公钥，服务器掌握私钥

3. 摘要算法（哈希值）：对内容计算出指纹（验证内容的完整性）

    - 1）哈希值是独一无二的
    - 2）无法通过哈希值推导出内容

## 加密过程

HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：

- 在通信建立前采用非对称加密的方式完成握手认证，然后交换「会话秘钥」，后续就不再使用非对称加密。
- 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据

综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取

## 他们之间的关联

-. 服务端：是拥有公钥和私钥的
-. CA：是拥有服务端的公钥的
-. 客户端：默认是没有任何密钥的

1. 服务器拥有的公钥，是已经注册到CA了的
2. CA用自己的私钥将服务器的公钥数字签名并颁发证书（服务器的公钥被放在了数字证书中）给服务器
3. CA的公钥已事先放到了浏览器或操作系统中（客户端可以访问到CA的公钥）
4. 在第一次TLS握手的时候，服务器回应客户端的时候，会返回服务器使用的证书给客户端
5. 客户端拿到服务器的数字证书，使用CA公钥解密效验证书，验证身份（可以获得服务器的公钥）
6. 使用服务器的公钥对报文进行加密发送

## CA数字证书

数字证书的存在时为了防止公钥信息被截取，因为没有办法确定得到的公钥就一定是安全的公钥。

因为可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。

数字证书签发和验证流程：

![ca-certificate](/static/images/ca-certificate.webp)

签发：

1. 首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，
2. 然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。
3. 最后将原始的信息和签名合在一起，称为数字证书。

验证：

1. 当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，
2. 然后使用公证处的公钥来对数字证书中的摘要进行解密，
3. 最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。

## TLS握手过程

1. 客户端向服务器发起加密通信请求

    - 这一步会向服务器发送这些信息：
    - 1）客户端支持的TLS协议版本
    - 2）客户端支持的密码套件
    - 3）客户端生产的**一个随机数**（后面用于生产会话密钥的参数之一）

2. 服务器发出响应

    - 回应的内容如下：
    - 1）确认TLS协议版本
    - 2）确认密码套件（用于后面使用加密的算法，比如：会话加密使用什么算法，摘要加密使用什么算法）
    - 3）服务器生产的**一个随机数**（后面用于生产会话密钥的参数之一）
    - 4）**数字证书**

3. 客户端回应

    - 客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
    - 1）客户端再生产**一个随机数**（后面用于生产会话密钥的参数之一），不过这里的随机数会被服务器的公钥加密
    - 2）加密通信算法改变通知，随后的信息都使用`会话密钥`加密通信
    - 3）客户端握手结束通知，并且把之前的所有内容的发生的数据做个摘要，用来供服务端校验

    服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。

4. 服务器的最后回应

    - 服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后向客户端发送最后的信息：
    - 1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
    - 2）服务器握手结束通知，同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

第3步与第4步中的对内容摘要给对方验证，可以这样理解：

在第3步中，客户端根据得到的3个随机，使用约定的加密套件，生成会话密钥，第4步同理；然后使用生成的会话密钥对内容进行加密传给对方，那么对方就可以使用刚生成的会话密钥进行加密，根据结果比对就可以验证是否OK。
