# 作用域与闭包

## 作用域

简单来说，作用域 指程序中定义变量的区域，它决定了当前执行代码对变量的访问权限。

javascript 中大部分情况下，只有两种作用域类型：

- 全局作用域：全局作用域为程序的最外层作用域，一直存在。
- 函数作用域：函数作用域只有函数被定义时才会创建，包含在父级函数作用域 / 全局作用域内。

### 作用域链

本地作用域 => 父级作用域 => 全局作用域

找到目标直接返回，否则会一直向上查找

### 块级作用域

简单来说，花括号内 {...} 的区域就是块级作用域区域。

注：javascript 不是原生支持块级作用域的

ES6标准之后 let const创建的为块级作用域

测试代码：

```js
if (true) {
  var a = 1;
}
console.log(a); // 1

if (true) {
  let a = 1;
}
console.log(a); // ReferenceError
```

### 词法作用域

- 词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。
- JavaScript是采用词法作用域的，这就意味着函数的执行依赖于函数定义的时候所产生（而不是函数调用的时候产生的）的变量作用域。

为了去实现这种词法作用域，JavaScript函数对象的内部状态不仅包含函数逻辑的代码，除此之外还包含当前作用域链的引用。函数对象可以通过这个作用域链相互关联起来，如此，函数体内部的变量都可以保存在函数的作用域内，这在计算机的文献中被称之为闭包。

严格意义上所有的函数都是闭包。

核心就是: 函数的作用域在函数定义的时候就决定了

> 需要注意的是：我们常常所说的闭包指的是让外部函数访问到内部的变量，也就是说，按照一般的做法，是使内部函数返回一个函数，然后操作其中的变量。这样做的话一是可以读取函数内部的变量，二是可以让这些变量的值始终保存在内存中。

## 闭包

**闭包是指有权访问另一个函数作用域中变量的函数**，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

也可以这样理解，闭包就是函数内部定义的函数，被返回了出去并在外部调用。

闭包有两个常用的用途：

- 创建私有变量：闭包使我们在函数外部能够访问到函数内部的变量，使用闭包，可以在外部调用闭包函数，从而在外部访问到函数内部的变量
- 保留变量对象在内存中：使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

```js
function foo() {
  var a = 2;

  function bar() {
    console.log( a );
  }

  return bar;
}

var baz = foo();

baz(); // 这就形成了一个闭包
```

认识到指针的作用，`foo()`的执行结果 `bar`函数被返回赋值给了 `baz`，这时虽然 `baz`在作用域之外，但是指针还是指向的 `bar`，因此哪怕它位于 foo 作用域之外，它还是能够获取到 foo 的内部变量。

### 垃圾回收机制

javascript 内部的垃圾回收机制用的是引用计数收集：

即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 0 的变量标记为失效变量并将之清除从而释放内存。

### 内存泄露

是指当一块内存不再被应用程序使用的时候，由于某种原因，这块内存没有返还给操作系统或者内存池的现象。内存泄漏可能会导致应用程序卡顿或者崩溃。

导致内存泄漏的行为操作：
  
- 全局变量的无意创建  
- 闭包使用过度导致内存占用无法释放的情况
- DOM 的事件绑定（移除 DOM 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露）

解决方案：

- 使用严格模式
- 避免过度使用闭包。
- 关注 DOM 生命周期，在销毁阶段记得解绑相关事件（或者可以使用事件委托的手段统一处理事件，减少由于事件绑定带来的额外内存开销）

## 总结

- javascript 语言层面只原生支持两种作用域类型：全局作用域 和 函数作用域 。
- 闭包的本质是利用了作用域的机制，来达到外部作用域访问内部作用域的目的。

## 资料

- [JavaScript深入之词法作用域和动态作用域](https://github.com/mqyqingfeng/Blog/issues/3)
- [面试官：说说作用域和闭包吧](https://juejin.cn/post/6844904165672484871)
