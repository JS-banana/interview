# 性能优化

性能优化主要分为两类：

1. 加载时优化
2. 运行时优化

例如压缩文件、使用 CDN 就属于加载时优化；减少 DOM 操作，使用事件委托属于运行时优化

在解决问题之前，必须先找出问题，否则无从下手。所以在做性能优化之前，最好先调查一下网站的加载性能和运行性能。

## 检查

- 检查加载性能：一个网站加载性能如何主要看白屏时间和首屏时间
  - 白屏时间：指从输入网址，到页面开始显示内容的时间。
  - 首屏时间：指从输入网址，到页面完全渲染的时间
- 检查运行性能：配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。

或者利用工具：

- sentry
- chrome 工具 Lighthouse

## 加载时性能优化 10 条规则

1. 减少 HTTP 请求
    - 一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程
    - 一般的小文件下载耗时可能也就 10 -20 ms，但是整个过程可能要花费200ms左右，因为每次连接时，都会涉及必要的 DNS 查找、TCP 握手、SSL等
    - 建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数
2. 使用 HTTP2
    - 解析速度快：服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。
    - 多路复用：HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。 多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。
    - 首部压缩：HTTP2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。
    - 优先级：HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。
    - 流量控制：流量控制可以对不同的流的流量进行精确控制。
    - 服务器推送：HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应
3. 使用服务端渲染
    - 优点是首屏渲染快，SEO 好，缺点是配置麻烦，增加了服务器的计算压力。
    - 客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。
    - 这样做的好处是什么？是更快的内容到达时间 (time-to-content)。
4. 静态资源使用 CDN
5. 将 CSS 放在文件头部，JavaScript 文件放在底部
    - CSS 执行会阻塞渲染，阻止 JS 执行
    - JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建
    - 为什么 CSS 文件还要放在头部：因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了
    - 另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。
6. 使用字体图标 iconfont 代替图片图标
    - 使用方便、矢量图、文件小
7. 善用缓存，不重复加载相同的资源
    - 通过添加 Expires 或 max-age 来控制
    - 指定 no-cache 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性
8. 压缩文件：压缩文件可以减少文件下载时间，让用户体验性更好
    - UglifyPlugin、CssMinimizerWebpackPlugin、HtmlWebpackPlugin、gzip
9. 图片优化
    - (1). 图片延迟加载：在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。
    - (2). 响应式图片：响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。
    - (3). 调整图片大小：可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。
    - (4). 降低图片质量：压缩方法有两种，一是通过 webpack 插件 image-webpack-loader，二是通过在线网站进行压缩。
    - (5). 尽可能利用 CSS3 效果代替图片
    - (6). 使用 webp 格式的图片
10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码
    - 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载（通过配置 output 的 filename 属性可以实现这个需求 `filename: '[name].[contenthash].js'`）
    - 提取第三方库
    - 使用 webpack4 的 splitChunk 插件 cacheGroups 选项
    - 减少 ES6 转为 ES5 的冗余代码
      - Babel 转化后的代码想要实现和原来代码一样的功能需要借助一些帮助函数
      - 如果在很多文件里都声明了类 class ，那么就会产生很多个这样的 helper 函数。
      - 这里的 @babel/runtime 包就声明了所有需要用到的帮助函数，而 @babel/plugin-transform-runtime 的作用就是将所有需要 helper 函数的文件，从 @babel/runtime包 引进来

## 运行时性能优化 13 条规则

1. 减少重绘重排
    - 用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式
    - 如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。
2. 使用事件委托
    - 事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。
3. 注意程序的局部性
    - 重复引用相同变量的程序具有良好的时间局部性
    - 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好；而在内存中以大步长跳来跳去的程序空间局部性会很差
4. if-else 对比 switch
    - 当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。
    - js 的 switch 语句不是基于哈希实现，而是循环判断，所以说 if-else、switch 从性能上来说是一样的
5. 查找表
    - 当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建。
    - 哈希表，前端中理解，object或者map，即 key: value 形式
6. 避免页面卡顿
    - 60fps 与设备刷新率
    - 大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒
7. 使用 requestAnimationFrame 来实现视觉变化
    - 在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 requestAnimationFrame。
8. 使用 Web Workers
    - Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面
    - Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。
9. 使用位操作
    - JavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。
10. 不要覆盖原生方法
    - 无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用 C/C++ 写的，并且被编译成机器码，成为浏览器的一部分。
    - 当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。
11. 降低 CSS 选择器的复杂性
    - (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取
    - (2). CSS 选择器优先级
        - `内联 > ID选择器 > 类选择器 > 标签选择器`
        - a. 选择器越短越好
        - b. 尽量使用高优先级的选择器，例如 ID 和类选择器
        - c. 避免使用通配符 *
12. 使用 flexbox 而不是较早的布局模型
    - 性能比较好
13. 使用 transform 和 opacity 属性更改来实现动画
    - 在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性

![composite](/static/images/css-composite.jpg)
