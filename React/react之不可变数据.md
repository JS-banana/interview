# react之不可变数据

思考一下redux规定reducer要是一个纯函数，即reducer不能直接更改传入的state对象，而是需要重新返回一个新的state对象，这是为什么？

## 可变数据 与 不可变数据

- 可变数据：一个数据被创建之后，可以随时进行修改，修改之后会影响到原值
  - JS的null、undefined、string、number、boolean、symbol都是不可变数据
  - object一般是可变数据
- 不可变数据（Immutable）：就是一旦创建，就不能再被更改的数据。
  - 对Immutable对象的任何修改或添加删除操作都会返回一个新的 Immutable对象

---

Immutable 实现的原理是Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。

## Immutable优点

1. Immutable降低了Mutable带来的复杂度
    - 可变（Mutable）数据耦合了Time和Value的概念，造成了数据很难被回溯
2、 节省内存
    - Immutable.js 使用了Structure Sharing会尽量复用内存。没有被引用的对象会被垃圾回收。
3、 Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟
    - 因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。
4、 拥抱函数式编程
    - Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。

## 不可变数据的几种实现方式

1. 使用解构写法
    <!-- 2. 使用深拷贝 -->
2. 使用 immutable.js、immer.js 等第三方库

## 不可变数据在项目中的运用

react项目中有两个地方用到了不可变数据

1. redux的使用上
2. setState的使用上

不可变数据能够为我们带来如下好处：

1. 不可变数据能够为我们带来如下好处
2. 更简单的编程和调试体验
3. 与可被随意篡改的数据相比，永远不变的数据更容易追踪，推导
4. 可以让复杂的变化检测机制得以简单快速的实现。从而确保代价高昂的DOM更新过程只在真正需要的时候进行
    - 比如 react hook 中的 useMemo 等

redux需要不变性的原因是：

1. redux与react-redux中对与state等相关对象的比对都使用的是**浅比较**
2. 不可变数据的管理极大地提升了数据处理的安全性
3. 进行时间旅行调试要求 reducer 是一个没有副作用的纯函数，以此在不同 state 之间正确的移动

浅比较和深比较有何区别？

简单来说，就是一个是 引用相等，一个是 值相等。

浅比较只检查两个不同 变量 是否为同一对象的引用；与之相反，深比较必须检查两个对象所有属性的值是否相等。

所以，浅比较就是简单的（且快速的）a === b，而深比较需要以递归的方式遍历两个对象的所有属性，在每一个循环中对比各个属性的值。

正是基于性能考虑，Redux 使用浅比较。

## react 的 setState

在react中规定state的变更如果要引起视图更新的话一定要显示的调用setState方法，并传入state；

而setState只会做一层state属性的合并
