# nodejs 单线程如何实现高并发

首先，明确一点，这里的单线程和浏览器中的JS单线程类似，指的是 主线程，即JS引擎只有一个实例。

node的单线程模式，只维持一个主线程，大大减少了线程间切换的开销，但是会有多个worker线程，用于执行异步操作。

<!-- node以事件驱动的方式处理IO等异步操 -->

也正因为如此，node不适合执行cpu密集型操作，准确的说是 主线程不建议执行密集型操作。

对于CPU密集型操作，在node中通过 child_process 可以创建独立的子进程，父子进程通过IPC通信，子进程可以是外部应用也可以是node子程序，子进程执行后可以将结果返回给父进程。

## NodeJS 运行机制

- 应用层：即 JavaScript 交互层，常见的就是 Node.js 的模块，比如 http、fs
- V8引擎层：即利用 V8 引擎来解析JavaScript 语法，进而和下层 API 交互
- NodeAPI层：为上层模块提供系统调用，一般是由 C 语言来实现，和操作系统进行交互
- LIBUV层：是跨平台的底层封装，实现了 事件循环、文件操作等，是 Node.js 实现异步的核心

![nodejs-system](/static/images/nodejs-system.png)

执行步骤：

1. V8引擎解析JavaScript脚本。
2. 解析后的代码，调用Node API。
3. libuv库负责Node API的执行。它将不同的任务分配给不同的worker线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。
4. V8引擎再将结果返回给用户。

## 事件循环

Node.js 通常情况下是单进程的。

- 主线程运行 V8 和 Javascript
- 多个子线程通过 事件循环 被调度

## 事件驱动+事件循环实现高并发

1. 每个Node.js进程只有一个主线程在执行程序代码，形成一个执行栈
2. 主线程之外，还维护了一个"事件队列"（Event queue）

    - 当用户的网络请求或者其它的异步操作到来时，node都会把它放到Event Queue之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。

3. 主线程代码执行完毕完成后，然后通过Event Loop，也就是事件循环机制，取出事件依次执行

    - 1）从 Event Queue 的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从线程池中分配一个线程去执行，然后第三个，第四个。
    - 2）主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，
    - 3）此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交EventLoop处理。
    - 4）当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。

注意：

我们所看到的node.js单线程只是一个js主线程与ui渲染共享一个线程，本质上的异步操作还是由**线程池**完成的，node将所有的阻塞操作都交给了内部的线程池去实现，**本身只负责不断的往返调度，并没有进行真正的I/O操作，从而实现异步非阻塞I/O，这便是node单线程和事件驱动的精髓之处了**。
