# 工作复盘

以往工作是面试中一定会考察的内容，面试官考察你的很多方面都是通过项目中的细节、思考、你做了什么、你能做什么、你擅长什么、以及你对项目的熟悉程度、你是真的参与这个项目还是写了凑数等等。

- 一定要对以往工作内容进行复盘总结，提炼精华。
- 必须能讲清楚做了什么、然后解决了什么难题（性能优化、提升效率等），因为面试会问。有些同学可能会说，平时都在增删改查，能有什么难题。其实即使不是你完成的，你也可以在看懂掌握后说是你做的，这个我觉得不算造假。

## ailpha数据平台

1. 开发aiql语法搜索器高级组件（Ailpha平台核心组件）

    - 基于 codemirror 编辑器实现，关键字特殊符匹配（=、!=、or、and、in、match等等，自定义了匹配规则），不同字段高亮显示，字典下拉选择框及内容数据根据条件动态渲染
    - 根据 codemirror 的鼠标事件，确定当前位置的字符，以及字符所属范围，如果是特殊字符，会结合前面的字段，在字典中进行过滤，筛选出符合条件的字段，然后渲染到下拉选择框
    - 支持键盘选择，
    - 选择框弹窗频繁的开和关，渲染卡顿，以数据模型的形式维护一个数据对象，基于此做字段的筛选等操作，再把最终的数据渲染到弹窗列表
    - 支持英文到中文的翻译，中文高亮显示保持一致，使用发布订阅，把切换后的状态传递到 codemirror 的自定义匹配文件中，使其可以在执行逻辑的时候，正确匹配当前的状态，进而高亮显示英文或中文

2. 支持关键字动态匹配的邮件编辑器的开发

    - 富文本编辑器，支持文本输入$关键字触发智能选择器逻辑，也支持${xx}变量字段的模糊匹配筛选，支持字段高亮
    - 难点：
    - 1）如何正确的替换当前选择的字段到编辑器中，使用原生光标对象 selection 与 range，确定起始位置，然后插入包裹好的字段到目标区域，进行替换
    - 2）一行中出现多个 ${} 包裹变量时，如何匹配到当前的输入变量 xx，根据JS原生 selectionchage 光标事件，获取当前 光标对象，确定位置后，双指针左右查找开闭符合 ${ 与 }，进而确定当前的输入变量
    - 3）${}字段末尾，光标位置定位错误问题，创建一个不可见的空节点放在后面，控制光标位置
    - 4）删除逻辑时，会有 第3步 类似的问题，

3. 模型管理模块、多层级表单，性能优化相关

    - 基于字典的不同字段类型，动态响应不同的表单输入，如input template 模板输入（可以通过选择的方式组合成模板）、select选择输入
    - 整个模型编辑页面，跨越多个层级、多个不同组件，在最上层绑定一个json数组，通过vue的响应式对每个子对象进行双向绑定修改，但是部分组件数据更新，需要使用deepclone进行深拷贝，触发组件的重新渲染，更新数据
    - 1）对于一部分字典数据，只是作为数据列表使用的，通过 Object.freez 方法对数据进行非响应式处理，优化 vue 对目标数据的响应式递归的性能消耗
    - 2）对于部分深拷贝触发的强制更新，考虑使用数组修改操作触发vue更新的监听，最小化更改部分数据，而达到触发 vue 更新的目的

## 微前端 qiankun 构建微应用

1. 为什么使用 qiankun，不使用 iframe？其他框架了解吗，有什么区别？
2. 你是如何做的？
3. 应用间的通信时如何做的？

    - 通过 qiankun 自带的 props 传递，传入一个封装后的 eventBus 进行数据的双向通信，同时在函数内部通过 vuex 进行数据响应式通知
    - 也可以使用 rxjs，思路是一样的，在主应用注册监听函数，然后把对象整个通过 props 传入子应用中
    - 以及部分全局数据，通过挂载在 window 进行传递

4. 子应用鉴权如何做的？
5. 路由

    - 主应用通过用户接口，获取到用户权限相关的 菜单数据，进行动态路由构建，创建子应用，通过 props 下发数据，在子应用中，初始化数据和路由，组装筛选后的路由，生成渲染
    - 子应用中的路由跳转需要调整（包括跨应用跳转），通过 history.push 方法与 window.open 方法，使用的路径前缀是有所不同的

6. 遇到的一些问题

    - 全局的起始引导页布局错位，intro.js

7. 多个应用间，公共模块、组件、库的处理方式，如何管理和共享

    - components 自定义组件及业务组件，以及一些封装指令、utils等，通过 git subtree 的方式进行多个应用间共享，通过在 gitlab中维护一个公共资源仓库，配置脚本用于更新和拉取
    - iconfont 只保留主应用中，全局子应用可以共享
    - 优化的方案是（项目中没这样做），把公共模块通过主应用共享下发至子应用，子应用打包时不在打包相关依赖

## 低代码平台

分为管理端、用户端；管理端用于搭建和配置页面，生成唯一的应用，用户端用于用户端，登录加载自己的默认应用。

两种实现方式：

- ① 基于内部的封装组件（components目录）： 一种是基于封装组件配置对应的 json 数据结构，根据不同 type 去渲染不同的组件
- ② 基于原子化：一种是基于更底层的原子化 json 数据结构，可以理解成 vue 的虚拟DOM，所有组件和数据都拆分到最小颗粒，最终通过一个渲染器实现组件和数据的显示

1. 整体概念

    - 左中右：组件面板、画布、配置面板
    - 数据管理
        - 左中右数据全局共享，通信，统一维护
        - 组件的配置数据等通过 json 数据结构表示，并储存到 数据库
    - 渲染器：这里的渲染器可以类似于 vue 等基于虚拟DOM的渲染方法实现，组件的相关render结构、配置属性与事件方法等，通过自定义的渲染器可以渲染到不同场景

2. json 方案

    - 在项目中，配置组件的默认属性和方法，维护一个组件目录（Button、Input、table等等），根据传入的参数对象，通过 RenderPlugin 动态渲染相应的组件，使用数据的 type参数（Button、Input等）确定应该使用那个组件渲染数据
    - 多层级嵌套，通过递归调用 RenderPlugin 依次渲染每个组件

    ```js
    const RenderPlugin = ({
        plugins,
        config,
        data
        /* 省略一系列参数 */
    }) => {
        // 这里的 layer 相当于直接引入 import layer from './input'
        let Layer = plugins.find(v => v.type === type)?.layer || null

        return <Layer {...data} config={config} >
            {
                data.layers && RenderPlugin({data ,config})
            }
        </Layer>
    }
    ```

3. 拖拉拽、改变组件尺寸（resizable）

    - 组件布局：
        - 自由布局：根据鼠标拖放位置进行定位，例如海报页、官网等
        - 自动布局：根据html块元素、行内元素进行布局，列如表单搭建这种场景

4. 路由及菜单

    - 导航栏部分：可自定义配置每个页面菜单路由，支持拖拉拽排序嵌套
    - 流程图：支持配置对应页面点击事件的跳转路由地址

## dasV 低代码可视化搭建平台

基于 json schema，实现了更小的原子化

组件作为独立物料存在，提供组件开发平台，自定义开发单个组件，开发完成通过git进行构建上传

## node相关，ssr、bff等

- ssr网站
- bff中间层

<https://doc.ssr-fc.com/>

1. ssr 中的 webpack 与普通 webpack 构建有所区别

    - React 服务端渲染构建是需要构建两份 JSBundle 文件。
    - 服务端的JSBundle用来生产HTML，客户端的JSBundle需要script到文档，用来进行事件绑定等操作，也就是 React 的 hydrate 机制。

2. 本地开发构建文件是放到内存中，SSR 如何读取文件进行渲染

    - 1）构建实例区别：
    - ssr 会启动两个 Webpack —— Node 模式 和 Web 模式；本地开发一般只有一个, 默认配置文件为项目根目录 webpack.config.js 文件
    - web 表示构建 JSBundle 给前端用，构建后文件目录 public；
    - node 表示构建 JSBundle 给 Node 端渲染用，构建后文件目录 app/xx
    - 2）构建内容形式区别：
    - 本地构建是 Webpack 内存构建，文件不落地磁盘，只有发布模式(npm run build)才能在目录中看到构建后的内容。
    - ssr 会生成 app/xx 和 public 两个目录文件。

3. Egg React SSR 发布模式如何渲染

    - 1）Webpack通过本地构建或者ci直接构建好服务端文件和客户端资源文件到磁盘
    - 2）Egg render直接读取本地文件, 然后渲染成 HTML
    - 3）根据 manfifest.json 文件注入 jss/css资源依赖注入
    - 4）模板渲染完成, 服务器输出HTML内容给浏览器

4. 使用koa搭建iview大屏模块的许可认证功能

    - 平台用户通过上传新的许可证文件，完成许可的更新操作，前端统一调用后端的许可接口，后端调用koa搭建的iview服务，完成对许可的解析认证和状态更新（认证操作是通过 本地封装的 shell 脚本文件完成执行，成功后会生成一个 SN码，该码被写入 temp 等文件，用于读取和验证）
